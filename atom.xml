<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[白驼山庄]]></title>
  <link href="https://chenrenyi.github.io/atom.xml" rel="self"/>
  <link href="https://chenrenyi.github.io/"/>
  <updated>2020-09-06T18:02:27+08:00</updated>
  <id>https://chenrenyi.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[短链实现]]></title>
    <link href="https://chenrenyi.github.io/15993836881187.html"/>
    <updated>2020-09-06T17:14:48+08:00</updated>
    <id>https://chenrenyi.github.io/15993836881187.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">跳转实现原理</h2>

<p>浏览器返回302跳转状态码</p>

<ul>
<li>301 永久跳转，浏览器下次不会再访问服务器，而是直接跳转</li>
<li>302 临时跳转，浏览器下次还会再返回，便于统计浏览次数等数据统计</li>
</ul>

<h2 id="toc_1">短链生成方式</h2>

<h3 id="toc_2">Hash法</h3>

<pre><code class="language-text">url.cn/hash后的原链接
</code></pre>

<h4 id="toc_3">1、对长链做哈希</h4>

<p><strong>MurmurHash法</strong><br/>
相比于sha、md5等，性能更高，分布更均匀，但相对不安全（个人理解为更容易反推）</p>

<h4 id="toc_4">2、若哈希得到数字，转化</h4>

<p>转化为62进制，进一步缩短长度（24个字母，大小写，加数字）</p>

<h4 id="toc_5">3、若哈希重复</h4>

<p>MySQL存储长短链映射关系，短链做唯一索引，插入时若失败则说明重复</p>

<p>重复时，给长链做转化，如增加特定后缀，再次哈希</p>

<h4 id="toc_6">4、布隆过滤器</h4>

<pre><code class="language-text">本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。

相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的
</code></pre>

<pre><code class="language-text">实现原理：
对同一个值，生成多个哈希，并记录多个哈希结果
如&#39;baidu&#39;，生成 1、4、7
查询时，若1、4、7均有占位，则说明可能存在
若1、4、7有任一一个不存在，则说明一定不存在
</code></pre>

<p><img src="media/15993836881187/15993841605651.jpg" alt=""/></p>

<h3 id="toc_7">自增ID</h3>

<pre><code class="language-text">url.cn/长链id
</code></pre>

<h4 id="toc_8">1、生成自增ID</h4>

<ul>
<li><p>类UUID，uuid.randomUUid，即机器识别码加uuid，缺点是长且无序，作db主键插入性能低</p></li>
<li><p>Redis，10台机器，每台生成以0-9结尾的自增序号，可提高性能。缺点是需要考虑持久化、容灾</p></li>
<li><p>雪花算法，机器ID+时间+随机串，缺点是若机器时间回滚有可能重复或乱序</p></li>
<li><p>MySQL自增主键</p></li>
</ul>

<h4 id="toc_9">2、MySQL自增主键</h4>

<p><strong>如何降低写压力</strong></p>

<ul>
<li>存储记号表，为每台机器提前生成一段范围内的ID</li>
<li>机器收到请求后，若在段内，直接返回ID。若不在，则请求再次生成一段ID。</li>
<li>机器将ID和长链映射关系保存</li>
<li>防止相同长链生成不同ID
<ul>
<li>对长链做md5并存为索引</li>
<li>生成时按索引查找</li>
</ul></li>
</ul>

<h2 id="toc_10">查询系统架构设计</h2>

<p><strong>OpenResty</strong><br/>
一个 nginx 和 lua 的集成平台，目的是直接在 nginx 内部完成业务逻辑，从而充分利用 nginx 的高并发优势</p>

<p><img src="media/15993836881187/15993849841395.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式]]></title>
    <link href="https://chenrenyi.github.io/15981744394317.html"/>
    <updated>2020-08-23T17:20:39+08:00</updated>
    <id>https://chenrenyi.github.io/15981744394317.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">分布式锁</h2>

<h3 id="toc_1">Reids分布式锁</h3>

<pre><code class="language-java">public class RedisTool {

    private static final String LOCK_SUCCESS = &quot;OK&quot;;
    private static final String SET_IF_NOT_EXIST = &quot;NX&quot;;
    private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;;

    /**
     * 尝试获取分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {

        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);

        if (LOCK_SUCCESS.equals(result)) {
            return true;
        }
        return false;

    }

    /**
     * 释放分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @return 是否释放成功
     */
    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {

        String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;
        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));

        if (RELEASE_SUCCESS.equals(result)) {
            return true;
        }
        return false;

    }
}    
</code></pre>
<br>
<p><strong>为何需要requestId</strong></p>

<ul>
<li>线程1执行逻辑为：加锁、执行逻辑、解锁</li>
<li>若线程1执行逻辑时间，超过锁有效期，则解锁时有可能解除了别人的锁</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>Redis 主从复制是异步的，主挂掉切换主后，可能有部分数据丢失，导致锁丢失</li>
</ul>

<h3 id="toc_2">数据库分布式锁</h3>

<ul>
<li>select for update</li>
<li>唯一索引</li>
<li>版本号</li>
</ul>

<h3 id="toc_3">Zookeeper分布式锁</h3>

<ul>
<li>创建临时有序节点来创建锁</li>
<li>获取所有节点，判断序号是否最小来判断是否有锁</li>
<li>监听上一节点来实现等待锁</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>创建临时锁的目的，是防止程序挂掉无法释放锁</li>
<li>也可能因为网络故障而错误释放锁</li>
</ul>

<h2 id="toc_4">分布式事务</h2>

<h3 id="toc_5">两阶段提交协议</h3>

<p>商业数据库自带</p>

<p>过程：<br/>
<img src="media/15981744394317/15981925713829.jpg" alt=""/><br/>
<img src="media/15981744394317/15981925853892.jpg" alt=""/></p>

<h3 id="toc_6">三阶段提交</h3>

<p><img src="media/15981744394317/15981926125149.jpg" alt=""/></p>

<p><img src="media/15981744394317/15981926185170.jpg" alt=""/></p>

<h3 id="toc_7">MQ事务</h3>

<p><img src="media/15981744394317/15981778819286.jpg" alt=""/></p>

<h2 id="toc_8">负载均衡</h2>

<h3 id="toc_9">算法</h3>

<ul>
<li>轮询</li>
<li>加权轮询</li>
<li>随机</li>
<li>最少连接</li>
<li>加权最小连接</li>
</ul>

<h3 id="toc_10">实现</h3>

<ul>
<li>DNS 解析</li>
<li>修改 Mac地址</li>
<li>修改 IP 地址</li>
<li>Http 重定向</li>
<li>Nginx 反向代理</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运维相关]]></title>
    <link href="https://chenrenyi.github.io/15981529091955.html"/>
    <updated>2020-08-23T11:21:49+08:00</updated>
    <id>https://chenrenyi.github.io/15981529091955.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">发布策略</h2>

<ul>
<li>蓝绿部署
<ul>
<li>部署一套实例数完全相同的新版本</li>
</ul></li>
<li>滚动部署
<ul>
<li>发布一定比例的新版本，关闭老版本。直至完全切换</li>
</ul></li>
<li>灰度发布/金丝雀发布
<ul>
<li>对应ABTest，先发布一部分到线上，观察无问题后切换</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络]]></title>
    <link href="https://chenrenyi.github.io/15981528120452.html"/>
    <updated>2020-08-23T11:20:12+08:00</updated>
    <id>https://chenrenyi.github.io/15981528120452.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">网络分层模型</h2>

<p><img src="media/15981528120452/15981528491746.jpg" alt=""/></p>

<p><img src="media/15981528120452/15981528604902.jpg" alt=""/></p>

<h2 id="toc_1">IO模式</h2>

<h3 id="toc_2">阻塞I/O</h3>

<p>普普通通</p>

<ul>
<li>进程发出IO请求后阻塞</li>
<li>操作系统完成后，唤醒进程</li>
</ul>

<h3 id="toc_3">非阻塞I/O</h3>

<p>操作系统不阻塞而是返回结果</p>

<ul>
<li>进程发出IO请求，不阻塞而是继续往下走</li>
<li>进程循环查询系统，系统立即返回完成/进行中</li>
</ul>

<pre><code class="language-text">特点是用户进程需要不断的主动询问kernel数据好了没有。
</code></pre>

<h3 id="toc_4">I/O多路复用</h3>

<p>即一个进程，通过一种机制，可以监听多个 IO 请求，多个 socket</p>

<p>也就是一个方法，同时监听10个连接。当有一个连接准备就绪后，方法就会返回，此时业务可以新起一个线程去处理该就绪连接。</p>

<h4 id="toc_5">select</h4>

<p>仅仅知道有IO事件发生，不知道具体是哪个事件，需要轮询</p>

<h4 id="toc_6">poll</h4>

<p>与select相同，区别在于没有最大连接数的限制</p>

<h4 id="toc_7">epoll</h4>

<p>即event poll，事件驱动。会告知调用时，哪个流发生哪个事件</p>

<h3 id="toc_8">异步IO</h3>

<p>发起 IO 后，进程不阻塞也不再关心。IO 完成时，操作系统主动把数据复制到用户空间并通知进程。</p>

<pre><code class="language-text">异步指的是：操作系统收到数据并复制到用户空间（即进程接收数据）这个步骤。

其它3种模式，进程接收数据时，均会阻塞。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LRU（last recent used）]]></title>
    <link href="https://chenrenyi.github.io/15981504896199.html"/>
    <updated>2020-08-23T10:41:29+08:00</updated>
    <id>https://chenrenyi.github.io/15981504896199.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-java">package fighting.algorithm.project;

import java.util.HashMap;
import java.util.Map;

/**
 * LRU：即last recent used，最近使用的队列
 * &lt;p&gt;
 * 作用：
 * 用于缓存，当内存满时，删除最近未使用的元素
 * &lt;p&gt;
 * 操作：
 * put(k, v)：插入元素，当内存满时需要先做清除。满足O(1)复杂度
 * get(k)：获取，同时设为最近使用。满足O(1)复杂度
 * &lt;p&gt;
 * 分析：
 * 最近使用关系，可使用元素顺序来表示，即队头是最近使用的，队尾的是最后使用的
 * 需要满足快速查询：哈希表
 * 满足元素顺序：链表
 * &lt;p&gt;
 * 结论：
 * 使用双向链表作为基础，最近使用的移到队头，内存不足时删除队尾的。双向的目的是做O(1)删除
 * 用哈希表来加速查询
 */
public class LRU {

    private Map&lt;Integer, Node&gt; map;

    private DoubleLinkedList doubleLinkedList;

    private int maxSize;

    private int size;

    public LRU(int maxSize) {
        this.maxSize = maxSize;
        doubleLinkedList = new DoubleLinkedList();
        map = new HashMap&lt;&gt;();
    }

    /**
     * 添加元素并移到队头
     * 1、已存在
     * 2、已满
     * 3、注意移到队头并更新size
     */
    public void put(int k, int value) {
        if (map.containsKey(k)) {
            doubleLinkedList.remove(map.get(k));
        } else if (size == maxSize) {
            Node deletedNode = doubleLinkedList.removeLast();
            map.remove(deletedNode.key);
        } else {
            size++;
        }

        Node newNode = new Node(k, value);
        doubleLinkedList.addFirst(newNode);
        map.put(k, newNode);
    }

    /**
     * 获取元素并移到队头
     */
    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        Node node = map.get(key);
        doubleLinkedList.remove(node);
        doubleLinkedList.addFirst(node);
        return node.value;
    }

    public static void main(String[] args) {
        LRU lru = new LRU(3);
        lru.put(1, 1);
        lru.put(2, 2);
        lru.put(3, 3);
        lru.put(4, 4);
        lru.doubleLinkedList.print();

        System.out.println(lru.get(2));
        lru.put(5, 5);
        lru.doubleLinkedList.print();
    }

    public static void doubleLinkedListTest() {
        Node node1 = new Node(1, 1);
        Node node2 = new Node(2, 2);
        Node node3 = new Node(3, 3);
        Node node4 = new Node(4, 4);

        DoubleLinkedList linkedList = new DoubleLinkedList();
        linkedList.addFirst(node4);
        linkedList.addFirst(node3);
        linkedList.addFirst(node2);
        linkedList.addFirst(node1);

        linkedList.print();
        linkedList.removeLast();
        linkedList.remove(node1);
        linkedList.print();
        linkedList.remove(node2);
        linkedList.removeLast();
        linkedList.print();
    }
}

/**
 * 链表节点
 */
class Node {
    public int key, value;
    public Node prev, next;

    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}

/**
 * 双向链表
 * 注意size为0（空队列），size为1（头尾相同）的情况
 * 注意对size做加减操作
 */
class DoubleLinkedList {
    private Node head, tail;
    private int size;

    /**
     * 添加到队头
     */
    public void addFirst(Node node) {
        if (size == 0) {
            head = tail = node;
            node.prev = node.next = null;
            size++;
            return;
        }

        node.next = head;
        head.prev = node;
        head = node;
        size++;
    }

    /**
     * 移除给定元素
     */
    public void remove(Node node) {
        if (node == tail) {
            removeLast();
            return;
        }

        size--;
        if (head == node) {
            head = node.next;
            return;
        }

        node.prev.next = node.next;
    }

    /**
     * 移除最后一个元素
     */
    public Node removeLast() {
        if (size == 0) {
            return null;
        }

        if (size == 1) {
            Node last = tail;
            head = tail = null;
            size = 0;
            return last;
        }

        Node last = tail;
        Node secondLast = tail.prev;
        secondLast.next = null;
        tail = secondLast;
        size--;
        return last;
    }

    public void print() {
        Node node = head;
        System.out.println();
        while (node != null) {
            System.out.println(node.value);
            node = node.next;
        }
        System.out.println();
    }
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[表达式求值]]></title>
    <link href="https://chenrenyi.github.io/15981499416448.html"/>
    <updated>2020-08-23T10:32:21+08:00</updated>
    <id>https://chenrenyi.github.io/15981499416448.html</id>
    <content type="html"><![CDATA[
<p>题目：<br/>
<a href="https://leetcode-cn.com/problems/basic-calculator-ii/">https://leetcode-cn.com/problems/basic-calculator-ii/</a></p>

<pre><code class="language-java">class Solution {
     public int calculate(String s) {
        LinkedList&lt;Integer&gt; integers = new LinkedList&lt;&gt;();
        LinkedList&lt;Character&gt; ops = new LinkedList&lt;&gt;();

        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (c == &#39; &#39;) {
                continue;
            }
            if (!Character.isDigit(c)) {
                ops.push(c);
                continue;
            }
            int number = c - &#39;0&#39;;
            while (i + 1 &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i + 1))) {
                i++;
                number = number * 10 + s.charAt(i) - &#39;0&#39;;
            }

            if (!ops.isEmpty()) {
                char lastOp = ops.peek();
                if (lastOp == &#39;*&#39;) {
                    ops.pop();
                    integers.push(integers.pop() * number);
                    continue;
                } else if (lastOp == &#39;/&#39;) {
                    ops.pop();
                    integers.push(integers.pop() / number);
                    continue;
                }
            }
            integers.push(number);
        }

        int res = integers.removeLast();
        while (!ops.isEmpty()) {
            char lastOp = ops.removeLast();
            if (lastOp == &#39;+&#39;) {
                res += integers.removeLast();
            } else {
                res -= integers.removeLast();
            }
        }
        return res;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BFS（广度优先搜索）问题]]></title>
    <link href="https://chenrenyi.github.io/15981493832715.html"/>
    <updated>2020-08-23T10:23:03+08:00</updated>
    <id>https://chenrenyi.github.io/15981493832715.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">框架</h2>

<pre><code class="language-cpp">// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue&lt;Node&gt; q; // 核心数据结构
    Set&lt;Node&gt; visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i &lt; sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
</code></pre>

<h2 id="toc_1">二叉树的最小深度</h2>

<p>题目：<br/>
<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 递归版本
    int min2(TreeNode root) {
        if(root == null) return 0;
        int left = min2(root.left);
        int right = min2(root.right);
        if(left != 0 &amp;&amp; right != 0) {
            return 1 + Math.min(left, right);
        } else {
            return 1 + left + right;
        }
    }

    public int minDepth(TreeNode root) {
        return min2(root);
    }

    // 非递归版本
    public int minDepth2(TreeNode root) {
        if(root == null) {
            return 0;
        }
        LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;();
        LinkedList&lt;TreeNode&gt; nextList = new LinkedList&lt;&gt;();
        int depth = 1;
        list.add(root);
        while(true) {
            if(list.isEmpty()) {
                if(nextList.isEmpty()) break;
                depth++;
                list = nextList;
                nextList = new LinkedList();
            }
            TreeNode node = list.removeFirst();
            if(node == null) {
                continue;
            }
            if(node.left == null &amp;&amp; node.right == null) {
                break;
            }
            nextList.add(node.left);
            nextList.add(node.right);
        }

        return depth;
    }
}
</code></pre>

<h2 id="toc_2">转盘锁</h2>

<p>题目：<br/>
<a href="https://leetcode-cn.com/problems/open-the-lock/">https://leetcode-cn.com/problems/open-the-lock/</a></p>

<pre><code class="language-java">class Solution {

    List&lt;Character&gt; nums;
    
    public int openLock(String[] deadLocks, String target) {
        nums = Arrays.asList(&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;);
        List&lt;String&gt; deadLockList = Arrays.asList(deadLocks);

        Set&lt;String&gt; list = new HashSet&lt;&gt;();
        Set&lt;String&gt; list2 = new HashSet&lt;&gt;();
        list.add(&quot;0000&quot;);
        list2.add(target);
        Set&lt;String&gt; visited = new HashSet&lt;&gt;(list);

        if (deadLockList.contains(target) || deadLockList.contains(&quot;0000&quot;)) {
            return -1;
        }

        visited.addAll(deadLockList);
        int step = 0;
        while (!list.isEmpty()) {
            Set&lt;String&gt; tmp = new HashSet&lt;&gt;(list);
            for (String lock : tmp) {
                list.remove(lock);
                if (list2.contains(lock)) {
                    return step;
                }
                visited.add(lock);

                LinkedList&lt;String&gt; nextLocks = getNextLocks(lock);
                for (String nextLock : nextLocks) {
                    if (visited.contains(nextLock)) {
                        continue;
                    }
                    list.add(nextLock);
                }
            }
            step++;
            Set&lt;String&gt; swap = list;
            list = list2;
            list2 = swap;
        }

        return -1;
    }

    LinkedList&lt;String&gt; getNextLocks(String lock) {
        LinkedList&lt;String&gt; nextLocks = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; lock.length(); i++) {
            StringBuilder newLock = new StringBuilder(lock);
            int index = nums.indexOf(newLock.charAt(i));
            char nextChar = nums.get((index + 10 + 1) % 10);
            newLock.replace(i, i + 1, String.valueOf(nextChar));
            nextLocks.add(newLock.toString());

            nextChar = nums.get((index + 10 - 1) % 10);
            newLock.replace(i, i + 1, String.valueOf(nextChar));
            nextLocks.add(newLock.toString());
        }
        return nextLocks;
    }

}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规则笔记]]></title>
    <link href="https://chenrenyi.github.io/15981488069038.html"/>
    <updated>2020-08-23T10:13:26+08:00</updated>
    <id>https://chenrenyi.github.io/15981488069038.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">框架</h2>

<pre><code class="language-text"># 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
</code></pre>

<h2 id="toc_1">斐波那契数</h2>

<pre><code class="language-java">class Solution {

    public int fib(int n) {
        if(n == 0 || n==1) {
            return n;
        }
        int answer = 0;
        int last = 1;
        int last_last = 0;
        for(int i=2; i&lt;=n; i++) {
            answer = last + last_last;
            last_last = last;
            last = answer;
        }
        return answer;
    }
}
</code></pre>

<h2 id="toc_2">零钱兑换</h2>

<pre><code class="language-text">题目：
给定不同面额的硬币 coins 和一个总金额 amount。
编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
如果没有任何一种硬币组合能组成总金额，返回 -1。
</code></pre>

<pre><code class="language-java">class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();


    // 非递归版本
    public int coinChange(int[] coins, int amount) {
        if(amount == 0) {
            return 0;
        }
        int[] arr = new int[amount + 1];
        for(int i=1; i&lt;arr.length; i++) {
            arr[i] = -1;
        }
        for(int coin: coins) {
            if(coin &lt; arr.length) arr[coin] = 1;
        }
        for(int i=1; i&lt;=amount; i++) {
            if(arr[i] != -1) continue;
            int min = i;
            boolean hasAnawer = false;
            for(int coin: coins) {
                if(i-coin &lt; 0) continue;
                if(arr[i-coin] == -1) continue;
                min = Math.min(min, arr[i-coin] + 1);
                hasAnawer = true;
            }
            if(hasAnawer) arr[i] = min;
        }
        return arr[amount];
    }

    // 递归版本
    public int coinChange2(int[] coins, int amount) {
        if(map.containsKey(amount)) return map.get(amount);

        if(amount == 0) {
            map.put(amount, 0);
            return 0;
        }

        if(amount &lt; 0) {
            map.put(amount, -1);
            return -1;
        }

        int min = amount;
        boolean hasAnawer = false;
        for(int coin : coins) {
            if(amount - coin &lt; 0) continue;
            int subAnswer = coinChange(coins, amount - coin);
            if (subAnswer == -1) continue;
            min = Math.min(min, subAnswer + 1);
            hasAnawer = true;
        }
        if (!hasAnawer) min = -1;
        map.put(amount, min);
        return min;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回溯算法]]></title>
    <link href="https://chenrenyi.github.io/15924514980743.html"/>
    <updated>2020-06-18T11:38:18+08:00</updated>
    <id>https://chenrenyi.github.io/15924514980743.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">框架</h2>

<pre><code class="language-text">回溯问题算法框架
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
</code></pre>

<h2 id="toc_1">全排列问题</h2>

<pre><code class="language-java">package fighting.algorithm.backtrack;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * 全排列问题
 */
public class Sequence {

    public static int answer_num = 0;

    /**
     * 回溯
     *
     * @param numbers 用于排列的数字
     * @param track   路径
     */
    public static void backtrack(List&lt;Integer&gt; numbers, LinkedList&lt;Integer&gt; track) {
        if (numbers.size() == track.size()) {
            System.out.println(track);
            answer_num++;
            return;
        }

        for (int i : numbers) {
            // 如果该数已在路径中，忽略
            if (track.contains(i)) {
                continue;
            }
            // 做选择
            track.add(i);
            // 递归进入之后的选择
            backtrack(numbers, track);
            // 撤销选择
            track.removeLast();
        }
    }

    /**
     * 测试
     */
    public static void main(String ars[]) {
        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);

        LinkedList&lt;Integer&gt; chooseList = new LinkedList&lt;&gt;();

        backtrack(numbers, chooseList);

        System.out.println(answer_num);
    }
}

</code></pre>

<h2 id="toc_2">N皇后问题</h2>

<pre><code class="language-java">package fighting.algorithm.backtrack;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * N皇后问题
 */
public class Queen {

    public static final int QUEEN_NUM = 8;

    public static List&lt;List&lt;List&lt;String&gt;&gt;&gt; results = new ArrayList&lt;&gt;();

    public static void queen(List&lt;List&lt;String&gt;&gt; board, int row) {
        if (row &gt;= QUEEN_NUM) {
            List&lt;List&lt;String&gt;&gt; boardCopy = initBoard();
            Collections.copy(boardCopy, board);
            results.add(boardCopy);
            return;
        }
        for (int column = 0; column &lt; QUEEN_NUM; column++) {
            if (isValid(board, row, column)) {
                board.get(row).set(column, &quot;Q&quot;);
                queen(board, row + 1);
                board.get(row).set(column, &quot;&quot;);
            }
        }
    }

    public static boolean isValid(List&lt;List&lt;String&gt;&gt; board, int row, int column) {
        // false if q exists in the same column
        for (int i = 0; i &lt; row; i++) {
            if (board.get(i).get(column).equals(&quot;Q&quot;)) {
                return false;
            }
        }

        for (int i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
            if (board.get(i).get(j).equals(&quot;Q&quot;)) {
                return false;
            }
        }

        for (int i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; QUEEN_NUM; i--, j++) {
            if (board.get(i).get(j).equals(&quot;Q&quot;)) {
                return false;
            }
        }

        return true;
    }

    public static List&lt;List&lt;String&gt;&gt; initBoard() {
        List&lt;List&lt;String&gt;&gt; board = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; QUEEN_NUM; i++) {
            board.add(new ArrayList&lt;&gt;());
            for (int j = 0; j &lt; QUEEN_NUM; j++) {
                board.get(i).add(&quot;&quot;);
            }
        }

        return board;
    }

    public static void printBoard(List&lt;List&lt;String&gt;&gt; board) {
        for (int i = 0; i &lt; QUEEN_NUM; i++) {
            for (int j = 0; j &lt; QUEEN_NUM; j++) {
                if (board.get(i).get(j).equals(&quot;Q&quot;)) {
                    System.out.print(&quot; ● &quot;);
                } else {
                    System.out.print(&quot; ○ &quot;);
                }
            }
            System.out.println();
        }
        System.out.println();
    }

    public static void main(String args[]) {
        List&lt;List&lt;String&gt;&gt; board = initBoard();
        queen(board, 0);

        System.out.println(results.size());
    }
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zuul 网关记录请求全生命周期日志]]></title>
    <link href="https://chenrenyi.github.io/15913291441737.html"/>
    <updated>2020-06-05T11:52:24+08:00</updated>
    <id>https://chenrenyi.github.io/15913291441737.html</id>
    <content type="html"><![CDATA[
<p>微服务架构中网关是所有对外提供服务的入口，一个常见的需求是对每个请求记录详细日志，包括url、method、header、request body、response status、response body等，方便问题排查而不用每个内部服务再做一套日志了。</p>

<p>以下为zuul框架搭建的网关记录全链路日志的方法。</p>

<h3 id="toc_0">思路介绍</h3>

<p>zuul有个处理代理请求工具类<code>ProxyRequestHelper</code>，用在关键的请求转发处理上。并且官方带一个子类<code>TraceProxyRequestHelper</code>，其中记录了不少debug信息和一些关键的钩子方法，包括我们需要的请求数据、转发模式等。因此继承这个子类，重写一些方法并把需要的信息，导出来存成日志即ok。</p>

<h3 id="toc_1">步骤源码</h3>

<p>1、如上面思路介绍，新建子类并继承<code>TraceProxyRequestHelper</code>，具体为什么这么改可以参见注释</p>

<pre><code class="language-java">import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.util.HTTPRequestUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.netflix.zuul.filters.TraceProxyRequestHelper;
import org.springframework.http.HttpHeaders;
import org.springframework.util.CollectionUtils;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StreamUtils;
import org.springframework.util.StringUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.springframework.http.HttpHeaders.CONTENT_ENCODING;
import static org.springframework.http.HttpHeaders.CONTENT_LENGTH;

/**
 * 继承zuul的实现，添加调试日志
 */
@Slf4j
public class MyTraceProxyRequestHelper extends TraceProxyRequestHelper {

    public static final String REQUEST_TRACE_DATA_KEY = &quot;MyRequestTraceData&quot;;

    public static final String RESPONSE_TRACE_DATA_KEY = &quot;MyResponseTraceData&quot;;

    /**
     * 在这里保存 request 的相关信息供之后导出来
     */
    @Override
    public Map&lt;String, Object&gt; debug(String verb, String uri, MultiValueMap&lt;String, String&gt; headers, MultiValueMap&lt;String, String&gt; params, InputStream requestEntity) throws IOException {
        Map&lt;String, Object&gt; result = super.debug(verb, uri, headers, params, requestEntity);
        RequestContext.getCurrentContext().getRequest().setAttribute(REQUEST_TRACE_DATA_KEY, result);
        return result;
    }

    /**
     * 在这里保存 response 的相关信息供之后导出来
     * 大部分代码复制自父类
     */
    @Override
    public void setResponse(int status, InputStream entity, MultiValueMap&lt;String, String&gt; headers) throws IOException {
        RequestContext context = RequestContext.getCurrentContext();
        context.setResponseStatusCode(status);

        // 记录response日志
        debugResponse(status, entity, headers);

        HttpHeaders httpHeaders = new HttpHeaders();
        for (Map.Entry&lt;String, List&lt;String&gt;&gt; header : headers.entrySet()) {
            List&lt;String&gt; values = header.getValue();
            for (String value : values) {
                httpHeaders.add(header.getKey(), value);
            }
        }
        boolean isOriginResponseGzipped = false;
        if (httpHeaders.containsKey(CONTENT_ENCODING)) {
            List&lt;String&gt; collection = httpHeaders.get(CONTENT_ENCODING);
            for (String header : collection) {
                if (HTTPRequestUtils.getInstance().isGzipped(header)) {
                    isOriginResponseGzipped = true;
                    break;
                }
            }
        }
        context.setResponseGZipped(isOriginResponseGzipped);

        for (Map.Entry&lt;String, List&lt;String&gt;&gt; header : headers.entrySet()) {
            String name = header.getKey();
            for (String value : header.getValue()) {
                context.addOriginResponseHeader(name, value);
                if (name.equalsIgnoreCase(CONTENT_LENGTH)) {
                    context.setOriginContentLength(value);
                }
                if (isIncludedHeader(name)) {
                    context.addZuulResponseHeader(name, value);
                }
            }
        }
    }

    /**
     * 新增的辅助方法，只有json等返回类型时才记录response日志
     * 判断response content-type是否是json、xml等正常接口返回类型
     */
    private boolean matchesMimeType(MultiValueMap&lt;String, String&gt; headers) {
        if (CollectionUtils.isEmpty(headers)) {
            return false;
        }
        String contentType = null;
        for (Map.Entry entry : headers.entrySet()) {
            if (entry.getKey().toString().equalsIgnoreCase(HttpHeaders.CONTENT_TYPE)) {
                List list = (ArrayList) entry.getValue();
                contentType = (String) list.get(0);
                break;
            }
        }
        if (StringUtils.isEmpty(contentType)) {
            return false;
        }
        String[] mimeTypes = new String[]{&quot;text/html&quot;, &quot;text/xml&quot;, &quot;application/xml&quot;, &quot;application/json&quot;};
        for (String mimeType : mimeTypes) {
            if (contentType.contains(mimeType)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 辅助方法
     * 实际记录response返回日志
     */
    private void debugResponse(int status, InputStream entity, MultiValueMap&lt;String, String&gt; headers) throws IOException {
        if (entity == null) {
            return;
        }

        // 非需要解析的content-type，不做处理
        RequestContext context = RequestContext.getCurrentContext();
        if (!matchesMimeType(headers)) {
            context.setResponseDataStream(entity);
            return;
        }

        byte[] entityByteArray = StreamUtils.copyToByteArray(entity);
        InputStream wrappedEntity = new ByteArrayInputStream(entityByteArray);

        //记录response
        char[] buffer = new char[4096];
        int count;
        boolean isSmallBody = true;
        try (InputStreamReader input = new InputStreamReader(wrappedEntity, StandardCharsets.UTF_8)) {
            count = input.read(buffer, 0, buffer.length);
            if (input.read() != -1) {
                isSmallBody = false;
            }
        }
        if (count &gt; 0) {
            String resp = new String(buffer).substring(0, count);
            context.getRequest().setAttribute(RESPONSE_TRACE_DATA_KEY, (isSmallBody ? resp : resp + &quot;&lt;truncated&gt;&quot;));
        }
        wrappedEntity.reset();
        context.setResponseDataStream(wrappedEntity);
    }

}
</code></pre>
<br>
<p>2、启用新建好的子类。新建个配置项，将自定义的子类，设置为<code>proxyRequestHelper</code>这个<code>bean</code>的默认实现(<code>@Primary</code>)</p>

<pre><code class="language-java">import org.springframework.boot.actuate.trace.InMemoryTraceRepository;
import org.springframework.cloud.netflix.zuul.ZuulProxyAutoConfiguration;
import org.springframework.cloud.netflix.zuul.filters.ProxyRequestHelper;
import org.springframework.cloud.netflix.zuul.filters.ZuulProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class MyZuulAutoConfiguration extends ZuulProxyAutoConfiguration {
    @Bean
    @Primary
    public ProxyRequestHelper proxyRequestHelper(ZuulProperties zuulProperties) {
        MyTraceProxyRequestHelper helper = new MyTraceProxyRequestHelper();
        helper.setTraces(new InMemoryTraceRepository());
        helper.setIgnoredHeaders(zuulProperties.getIgnoredHeaders());
        helper.setTraceRequestBody(zuulProperties.isTraceRequestBody());
        return helper;
    }
}

</code></pre>
<br>
<p>3、获取日志内容并实际写入日志。这儿可以建一个spring的请求拦截器<code>OncePerRequestFilter</code>，记录请求耗时并在处理完毕后写入日志。</p>

<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * 添加调试日志信息
 */
@Configuration
@Slf4j
public class LogFilter extends OncePerRequestFilter {

    public static final String REQUEST_BEGIN_TIME = &quot;REQUEST_BEGIN_TIME&quot;;

    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {
        httpServletRequest.setAttribute(REQUEST_BEGIN_TIME, System.currentTimeMillis());
        filterChain.doFilter(httpServletRequest, httpServletResponse);
        traceLog(httpServletRequest);
    }

    /**
     * 记录日志
     */
    private void traceLog(HttpServletRequest request) {
        Long begin = (Long) request.getAttribute(REQUEST_BEGIN_TIME);
        if (begin == null || begin == 0L) {
            begin = System.currentTimeMillis();
        }

        Map&lt;String, Object&gt; logData = new LinkedHashMap&lt;&gt;();
        Map&lt;String, Object&gt; requestMap = (Map&lt;String, Object&gt;) request.getAttribute(REQUEST_TRACE_DATA_KEY);
        logData.put(&quot;url&quot;, request.getRequestURL());
        logData.put(&quot;uri&quot;, request.getRequestURI());
        logData.put(&quot;timeCost&quot;, System.currentTimeMillis() - begin);
        if (requestMap != null) {
            logData.putAll(requestMap);
        }
        logData.put(&quot;responseBody&quot;, StringUtils.abbreviate(String.valueOf(request.getAttribute(RESPONSE_TRACE_DATA_KEY)), 128));

        log.info(&quot;{}&quot;, logData);
    }
}

</code></pre>
<br>
<p><strong>ok了，至此大功告成！</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iText 生僻字显示设置与汉字数字化]]></title>
    <link href="https://chenrenyi.github.io/15827936185226.html"/>
    <updated>2020-02-27T16:53:38+08:00</updated>
    <id>https://chenrenyi.github.io/15827936185226.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">问题描述</h2>

<p>iText 生成的 pdf，无法显示某些生僻字，比如【㙓】、【𠅤】。在遇到生僻字时不会显示成方块，而是直接不显示。<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_1">原来生成 pdf 的过程</h2>

<p>1、用 FreeMarker 模板引擎生成 html，html 里面的 css 指定了字体文件<br/>
<a href="media/15827936185226/docs.css">docs</a></p>

<pre><code class="language-css">body {font-family: SimSun}
</code></pre>

<p>2、添加 SimSun 字体文件</p>

<pre><code class="language-java">new ITextRenderer().getFontResolver().addFont(&quot;SimSun.ttf&quot;)
</code></pre>

<p>3、用 iText 框架将 html 转化成 pdf 文件</p>

<pre><code class="language-java">renderer.setDocumentFromString(content, storagePath);
</code></pre>

<h2 id="toc_2">原因分析</h2>

<p>原因简单说来，就是 SimSun.ttf（中易宋体，也是 windows 系统默认字体）中未收录某些生僻字，所以生成的 pdf 中显示不出来。</p>

<p>至于为啥不收录以及对应的解决办法，需要先了解下计算机是如何显示汉字的。或者也可以直接跳过看最终解决方案，再回过头看原理。</p>

<h2 id="toc_3">汉字的数字化历史</h2>

<h3 id="toc_4">汉字有多少个</h3>

<p>生活中的情况：我国义务教育阶段要求识字 3500 个左右，2013 年国务院发布的《通用规范汉字表》，收录汉字 8105 个，分为三级，其中一级字为常用字共 3500个，二级字 3000 个，三级字 1605 个。</p>

<p>书本中的情况：东汉的《说文解字》收字 9353 个，清朝《康熙字典》收字 47,035 个，当代的《汉语大字典》（2010 年版) 收字 60,370 个。 1994 年中华书局、中国友谊出版公司出版的《中华字海》收字 85,568 个。</p>

<p>据估算总汉字约 10 万个，具体数字无人清楚。</p>

<h3 id="toc_5">把汉字放进计算机，汉字编码历史</h3>

<p>想用计算机传输存储文字，必然要有编码方案。但汉字实在太多，所以编码方案是演进型的，初期只收录的字数很少，后面才慢慢扩充。</p>

<h4 id="toc_6">国标：</h4>

<p>1981 年：发布 GB2312—1980，收录汉字 6763 个和非汉字图形字符 682 个<br/>
1995 年：发布 GBK，收录 21886 个汉字和图形符号<br/>
2001 年：发布 GB18030，共收录汉字 70,244 个</p>

<h4 id="toc_7">unicode：</h4>

<p>unicode 的目的是国际通行，而国际上汉字使用除中国外，还有日韩。因此为了统一汉字编码，有了中日韩统一表意文字 (即 CJK，各国英文名首字母)。为啥要讲 unicode 呢，因为编程语言对它的支持好啊。</p>

<p>从1991年到2018年，先是发布了第一版，后来陆续增加了扩展表 A、B、C、D、E、F区</p>

<h3 id="toc_8">把汉字显示出来，字体文件</h3>

<p>有了编码方案，还要有字体文件，知道如何把汉字画出来。因为汉字数量太多，编码方案是演进型的，所以字体文件也只提供了一部分汉字。</p>

<p>常用字体文件格式：<br/>
ttf：最常用的，微软和苹果合推的<br/>
ttc：本质是多个ttf的集合<br/>
otf：是ttf的升级版，测试发现iText框架貌似不支持</p>

<p>我从网上下载的许多号称超大字符集的字体文件，里面都是分为好几个 ttf 文件的。有两个原因，一是常用字已经有字体文件了，因此只需要再提供一份生僻字的文件即可。二是有ttf格式有数量上限，没法放下全部的字。</p>

<h2 id="toc_9">字体显示的 fallback 机制</h2>

<p>上面解释了为什么单个字体文件没包含所有字，但实际上的情况是，有些字在系统上和浏览器中能看到，比如举例中的【𠅤】，而 pdf 中却不显示呢？</p>

<h3 id="toc_10">操作系统/浏览器是怎么处理字体缺失的？</h3>

<p>fallback，即回退机制：如果指定用字体 A 来显示某字符 x，但该字体并不支持这个字符（甚至该字体当前不可用），排版引擎通常不会直接放弃，它会根据一个预先记好的列表来尝试寻找能显示字符 x 的字体，如果找到字体 B 能行，那就用字体 B 来显示字符 x。字体 B 就是当前这个情况的 fallback。</p>

<h3 id="toc_11">生成 pdf 时为啥不支持 fallback？</h3>

<p>pdf：主要用于打印和阅读，而非编辑。有一个特点是：它可以将文字、字型、格式、颜色及独立于设备和分辨率的图形图像等封装在一个文件中，个人理解就是跟图片一样，封装了所有的显示效果，所以无论在什么平台打开，排版效果都是一样的。</p>

<p>所以它是一个独立的不依赖于平台的格式，个人猜测这也就是为什么它不支持操作系统的fallback机制。</p>

<h2 id="toc_12">解决方案</h2>

<p>知道了单个字体不包含所有文件，pdf 也不支持 fallback 机制后，解决方案如下：</p>

<p>1、引入最新版 SimSun.ttf，SimSun-extB.ttf 两个文件，我从 win10 最新版中导入的，经测试前者包含 cjk 与扩展 A 区的字体，后者包含其它区的字体。</p>

<p>2、iText 框架添加上面两个字体，参见 2.2</p>

<p>3、html 中指定默认字体为 SimSun，参见 2.1</p>

<p>4、遍历 html 内容，扫描出 B 区及以后的字体，手动指定字体格式 SimSun-ExtB。代码如下：</p>

<pre><code class="language-java">    /**
     * 扫描待转化成pdf的html内容，为生僻字指定生僻字体，解决生僻字不显示的问题
     */
    private String addFontFamilyForUncommonWords(String string) {
        int[] stringUnicodes = StringUtils.toCodePoints(string);
        StringBuffer resultString = new StringBuffer();

        for (int charUnicode : stringUnicodes) {
            // 中易宋体(simsun)含有常规字符及cjk扩展表A的内容，中易宋体扩展版(simsun-extb)有cjk其它扩展表区内容
            Character.UnicodeBlock ub = Character.UnicodeBlock.of(charUnicode);
            if (ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B
                    || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C
                    || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D) {
                resultString.append(&quot;&lt;font style=&#39;font-family: SimSun-ExtB&#39;&gt;&quot;);
                resultString.append(Character.toChars(charUnicode));
                resultString.append(&quot;&lt;/font&gt;&quot;);
            } else {
                resultString.append(Character.toChars(charUnicode));
            }
        }

        return resultString.toString();
    }
</code></pre>

<h2 id="toc_13">其它方案</h2>

<h3 id="toc_14">1、换框架，不用 iText。</h3>

<p>网上搜索其它 pdf 框架结果很少，因此未作尝试</p>

<h3 id="toc_15">2、css 中指定多个字体解决</h3>

<p>经测试，在 css 的 font-family 中指定多个字体，生成 pdf 时只按顺序使用第一个存在的字体，即常用字体在前只显示常用字，生僻字体在前只显示生僻字。原因相关知识中有写，生成 pdf 时不支持 fallback 机制。</p>

<h3 id="toc_16">3、默认字体指定为一个超全超大的字体文件</h3>

<p>相关知识中有介绍，ttf 格式有字形上限，收录字形想全必须存在多个文件。同时 iText 不支持 otf 格式，支持 ttc 格式但必须指定序号，即用 ttc 中包含的哪一个 ttf，因此不行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一篇文章]]></title>
    <link href="https://chenrenyi.github.io/15818551802185.html"/>
    <updated>2020-02-16T20:13:00+08:00</updated>
    <id>https://chenrenyi.github.io/15818551802185.html</id>
    <content type="html"><![CDATA[
<p>因新冠肺炎疫情呆在家里的第 26 天，闲来无事第 n 次搭建博客，写下同样第 n 次的开篇文章。</p>

<span id="more"></span><!-- more -->

<p>这一次用的 Mweb（页脚权限声明那有官网链接），Mac 上一个 Markdown 写作软件，自带静态博客创建和发布功能，支持自定义发布脚本。日常在编辑器书写，完成后一键发布即可。</p>

<p>当然了，这软件是收费的。国内开发者，做得挺用心。比如我个人很喜欢的一个小功能是，“在中文和半角的英文、数字之间插入空格”，Github 上也有开源实现，称呼这种空格为盘古白，各编程语言版本都有。与 Word 和手机微信的聊天框显示效果类似。其实代码实现并不复杂，但能从中一窥作者对排版和用户体验的细节追求。</p>

<p>有缘看到的兄弟可以试试。如果软件作者看到了，记得给我打钱啊😆</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全]]></title>
    <link href="https://chenrenyi.github.io/15981025908754.html"/>
    <updated>2020-08-22T21:23:10+08:00</updated>
    <id>https://chenrenyi.github.io/15981025908754.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">大纲</h2>

<ul>
<li>系统设计
<ul>
<li>精细化的权限模型</li>
<li>比如 ID 遍历问题信息泄漏问题</li>
</ul></li>
<li>常见安全问题
<ul>
<li>见后面详述</li>
</ul></li>
<li>环境安全
<ul>
<li>比如文件系统权限应精细设置，不能一概 777</li>
<li>php.ini 设置、mysql 设置应采用安全设置，禁用掉危险函数配置等</li>
<li>及时打补丁修复漏洞</li>
<li>框架采用长期版本 LTS 版本</li>
</ul></li>
</ul>

<h2 id="toc_1">XSS 跨站脚本 Cross-site scripting</h2>

<p>解决办法：</p>

<ul>
<li>过滤特殊字符</li>
<li>使用 HTTP 头指定类型</li>
</ul>

<h2 id="toc_2">CSRF 跨站请求伪造 Cross-site request forgery</h2>

<p>是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作</p>

<p>这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>

<p>解决办法：</p>

<ul>
<li>检查 Referer 字段</li>
<li>添加校验 token</li>
</ul>

<h2 id="toc_3">SQL注入</h2>

<p>扫描工具：sqlmap</p>

<p>解决办法：</p>

<ul>
<li>参数预绑定，或者使用ORM框架的参数绑定</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zookeeper]]></title>
    <link href="https://chenrenyi.github.io/15981025270346.html"/>
    <updated>2020-08-22T21:22:07+08:00</updated>
    <id>https://chenrenyi.github.io/15981025270346.html</id>
    <content type="html"><![CDATA[
<p>分布式协调框架</p>

<h2 id="toc_0">场景</h2>

<ul>
<li>数据发布/订阅（配置中心）
<ul>
<li>树形结构且节点可存储数据，天然配置中心。</li>
<li>关注节点以接收通知，然后可以动态获取配置信息</li>
</ul></li>
<li>命名服务 / 负载均衡
<ul>
<li>生成全局唯一ID</li>
</ul></li>
<li>分布式协调/通知</li>
<li>心跳检测
<ul>
<li>A服务创建临时节点，A关闭后临时节点即断掉</li>
<li>B服务查看有多少临时节点，即知道有多少服务活着</li>
</ul></li>
<li>集群管理</li>
<li>Master选举
<ul>
<li>选举时，各备选机器创建一个相同临时的znode</li>
<li>谁创建成功，谁成为master</li>
<li>失败的，关注该节点</li>
<li>若master挂掉，其余节点能够立刻感知，从而重新选举</li>
</ul></li>
<li>分布式锁和分布式队列
<ul>
<li>排它锁
<ul>
<li>临时znode，满足只有一个事务可以获得锁，释放后能通知的功能</li>
</ul></li>
<li>共享锁
<ul>
<li>创建临时有序znode，value标记为 写、读</li>
<li>获取读锁：若比当前节点序号小的都是读锁，则认为获取成功</li>
<li>获取写锁：若自己就是最小节点，则认为获取成功</li>
<li>否则注册监听事件</li>
</ul></li>
</ul></li>
</ul>

<h2 id="toc_1">保证的特性</h2>

<ul>
<li>顺序一致性
<ul>
<li>同一客户端发起的请求，会按顺序应用到服务器</li>
</ul></li>
<li>原子性
<ul>
<li>事务结果在所有机器上一样</li>
</ul></li>
<li>单一视图
<ul>
<li>客户端连接任意服务器，看到的结果一样</li>
</ul></li>
<li>可靠性
<ul>
<li>持久化</li>
</ul></li>
<li>实时性
<ul>
<li>在一定的时候内，能看到最新的数据</li>
</ul></li>
</ul>

<h2 id="toc_2">集群角色</h2>

<ul>
<li>Leader</li>
<li>Follower</li>
<li>Observer
<ul>
<li>默认无该角色</li>
<li>可提供读，不提供写</li>
<li>不参与写的过半写成功策略</li>
<li>不参与 Leader 选举</li>
<li>作用：在不影响写的性能下，增加读性能</li>
</ul></li>
</ul>

<h2 id="toc_3">数据</h2>

<pre><code class="language-text">[zk: localhost:2181(CONNECTED) 23] get /yarn-leader-election/appcluster-yarn/ActiveBreadCrumb

appcluster-yarnrm1
cZxid = 0x1b00133dc0    //Created ZXID,表示该ZNode被创建时的事务ID
ctime = Tue Jan 03 15:44:42 CST 2017    //Created Time,表示该ZNode被创建的时间
mZxid = 0x1d00000063    //Modified ZXID，表示该ZNode最后一次被更新时的事务ID
mtime = Fri Jan 06 08:44:25 CST 2017    //Modified Time，表示该节点最后一次被更新的时间
pZxid = 0x1b00133dc0    //表示该节点的子节点列表最后一次被修改时的事务ID。注意，只有子节点列表变更了才会变更pZxid，子节点内容变更不会影响pZxid。
cversion = 0    //子节点的版本号
dataVersion = 11    //数据节点的版本号
aclVersion = 0    //ACL版本号
ephemeralOwner = 0x0    //创建该节点的会话的seddionID。如果该节点是持久节点，那么这个属性值为0。
dataLength = 22    //数据内容的长度
numChildren = 0    //子节点的个数
</code></pre>

<h2 id="toc_4">其它概念</h2>

<h3 id="toc_5">Watcher</h3>

<pre><code class="language-text">Watcher（事件监听器），是ZooKeeper中一个很重要的特性。
ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去。
该机制是ZooKeeper实现分布式协调服务的重要特性。
</code></pre>

<h3 id="toc_6">事务</h3>

<p>能改变zookeeper服务器状态的称为事务，如节点创建、删除、更新等。事务号为zxid</p>

<h3 id="toc_7">ACL</h3>

<p>access control Lists 控制权限</p>

<ul>
<li>CREATE: 创建子节点的权限。</li>
<li>READ: 获取节点数据和子节点列表的权限。</li>
<li>WRITE：更新节点数据的权限。</li>
<li>DELETE: 删除子节点的权限。</li>
<li>ADMIN: 设置节点ACL的权限。</li>
</ul>

<h2 id="toc_8">ZAB协议</h2>

<pre><code class="language-text">所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而剩下的其他服务器则成为Follower服务器。
Leader服务器负责将一个客户端事务请求转换成一个事务Proposal（提案）并将该Proposal分发给集群中所有的Follower服务器。
之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，
Leader就会再次向所有的Follower服务器分发Commit消息，要求对刚才的Proposal进行提交。
</code></pre>

<h3 id="toc_9">读写过程</h3>

<h4 id="toc_10">写Leader</h4>

<ul>
<li>客户端向Leader发起写请求</li>
<li>Leader发送提案给所有Follower并等待ACK</li>
<li>过半Follower回复ACK，Leader自己也有一票ACK，向所有Follower、Observer发送commit</li>
<li>返回结果给客户端</li>
</ul>

<h4 id="toc_11">写Follower、Observer</h4>

<ul>
<li>转发给Leader</li>
<li>同写Leader</li>
</ul>

<h4 id="toc_12">读</h4>

<ul>
<li>直接从本地内存读取后返回</li>
</ul>

<h3 id="toc_13">选举过程</h3>

<p><a href="https://dbaplus.cn/news-141-1875-1.html">选举过程</a></p>

<h3 id="toc_14">两种模式</h3>

<p><strong>恢复模式</strong></p>

<p>服务启动或Leader挂掉后，进入恢复模式。<br/>
Leader选举完成，且大部分节点完成状态同步后，退出恢复模式</p>
<br>
<p><strong>广播模式</strong></p>

<p>正常维持在广播状态<br/>
新节点加入时，会在恢复模式下启动，以完成状态同步</p>

<h2 id="toc_15">面试问题</h2>

<h3 id="toc_16">如何保证事务的顺序一致性</h3>

<p>通过事务号zxid，</p>

<ul>
<li>高32位：世代号，每次出现新Leader即加1</li>
<li>低32位：每次新事务加1</li>
</ul>

<h3 id="toc_17">部署模式</h3>

<ul>
<li>单机</li>
<li>集群</li>
<li>伪集群（单机多实例）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux]]></title>
    <link href="https://chenrenyi.github.io/15981005517872.html"/>
    <updated>2020-08-22T20:49:11+08:00</updated>
    <id>https://chenrenyi.github.io/15981005517872.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">lsof（list open files）</h2>

<pre><code class="language-bash"># 查看端口占用
lsof -i:80
</code></pre>

<h2 id="toc_1">top</h2>

<p>显示信息：</p>

<ul>
<li>系统时间</li>
<li>cpu</li>
<li>内存</li>
<li>交换空间</li>
<li>线程</li>
</ul>

<pre><code class="language-text">top - 17:19:17 up 1112 days,  6:25,  4 users,  load average: 0.36, 0.34, 0.61
Tasks: 184 total,   2 running, 181 sleeping,   0 stopped,   1 zombie
Cpu(s): 14.6%us,  9.2%sy,  5.5%ni, 69.9%id,  0.0%wa,  0.0%hi,  0.2%si,  0.6%st
Mem:   1927548k total,  1879924k used,    47624k free,   319916k buffers
Swap:  3145712k total,  1894636k used,  1251076k free,   353284k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 8448 chenreny  20   0  215m  14m 4072 S  5.1  0.8   0:02.99 php-fpm
 2755 nobody    30  10  850m 3384 1044 S  4.3  0.2   3845:50 minos-agent-tk
 8483 chenreny  20   0  215m  14m 4056 S  4.3  0.8   0:02.83 php-fpm
 2546 nobody    30  10  850m 3372 1044 S  4.1  0.2   3855:48 minos-agent
</code></pre>

<h2 id="toc_2">free</h2>

<p>查看可用内存</p>

<h2 id="toc_3">vmstat</h2>

<p>查看内存信息</p>

<h2 id="toc_4">iostat</h2>

<p>显示io信息，可查看cpu idle信息</p>

<pre><code class="language-text">Linux 2.6.32_1-16-0-0_virtio (cp01-sys-ump-ur-dev14.epc.baidu.com)  11/27/2019  _x86_64_    (1 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          15.32    3.96    9.74    5.49    4.56   60.92

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
vda              12.87       625.63       104.02 60056660458 9985065320
vdb             194.53      1760.93        60.82 169039945506 5838059600
</code></pre>

<h2 id="toc_5">sar System Activity Reporter（系统活动报告）</h2>

<p>查看系统历史监控信息，比如查看过去一段时间内 idle 变化</p>

<h2 id="toc_6">pstack</h2>

<p>打印内存堆栈信息，用于进程卡死时debug，java 程序可用 jstack</p>

<h2 id="toc_7">文字处理</h2>

<h3 id="toc_8">awk 或 sed</h3>

<pre><code class="language-text">ls -l | awk &#39;{print $1}&#39;
</code></pre>

<h3 id="toc_9">uniq</h3>

<pre><code class="language-text">uniq testfile # 去重显示
uniq -c testfile # 去重并显示重复数，重复行不相邻时无效
uniq -d testfile # 仅显示重复行
sort  testfile1 | uniq -c
</code></pre>

<h3 id="toc_10">wget</h3>

<pre><code class="language-text">wc -l testfile # 统计行号
wc -w testfile # 统计字数
</code></pre>

<h2 id="toc_11">其它常用</h2>

<p>grep、df、dh、strace（跟踪系统调用）</p>

<h2 id="toc_12">参考资料</h2>

<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html">工具参考篇</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis]]></title>
    <link href="https://chenrenyi.github.io/15980994076315.html"/>
    <updated>2020-08-22T20:30:07+08:00</updated>
    <id>https://chenrenyi.github.io/15980994076315.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">数据类型和命令</h2>

<h3 id="toc_1">string</h3>

<pre><code class="language-text">set
get
</code></pre>

<h3 id="toc_2">list</h3>

<pre><code class="language-text">lpush
lpop
rpush
rpop
</code></pre>

<p>底层实现是链表，量少时为zipset，即数组的连续区域。量大时为quickset，即将多个zipset用指针连接起来</p>

<h3 id="toc_3">hash</h3>

<pre><code class="language-text">hset
hget
</code></pre>

<h3 id="toc_4">set</h3>

<pre><code class="language-text">sadd
smembers
</code></pre>

<h3 id="toc_5">sortedset</h3>

<pre><code class="language-text">zadd
zrange
</code></pre>

<p>底层实现为跳跃列表，跳表</p>

<h2 id="toc_6">跳表</h2>

<p>个人总结：</p>

<ul>
<li>首先是一个有序链表</li>
<li>为了提高查询速度，给每个节点增加多个索引，指向更后面的节点。由O(n) ——&gt; O(log(n))</li>
<li>抛硬币决定加几层索引，即第一层100%，第二层50%，第三层25%...</li>
</ul>

<p>为啥不用平衡树（平衡排序树）：</p>

<ul>
<li>插入删除不用调整子树，更简单迅速</li>
<li>范围查找比平衡树好</li>
<li>算法实现简单</li>
</ul>

<p><img src="media/15980994076315/%E8%B7%B3%E8%A1%A8.svg" alt="跳表"/></p>

<h2 id="toc_7">集群模式</h2>

<h3 id="toc_8">主从复制</h3>

<p>介绍：</p>

<ul>
<li>主服务器读写</li>
<li>从服务器备份，提供读</li>
</ul>

<p>特点：</p>

<ul>
<li>读写分离</li>
<li>容灾恢复</li>
</ul>

<p>缺点：</p>

<ul>
<li>写能力未提高</li>
<li>不支持自动恢复</li>
<li>故障时可能有部分数据未同步</li>
</ul>

<h3 id="toc_9">哨兵模式</h3>

<p>带哨兵的主从复制模式，可以自动切换master</p>

<h3 id="toc_10">集群模式</h3>

<p>分布式的多节点<br/>
每个节点带从节点，带监控模式，可以自动切换 master</p>

<h2 id="toc_11">应用场景</h2>

<ul>
<li>分布式缓存</li>
<li>分布式锁</li>
</ul>

<h2 id="toc_12">参考文章：</h2>

<p><a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16">通俗易懂的Redis数据结构基础教程</a></p>

<p><a href="https://lotabout.me/2018/skip-list/">跳表──没听过但很犀利的数据结构</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java基础]]></title>
    <link href="https://chenrenyi.github.io/15980638067464.html"/>
    <updated>2020-08-22T10:36:46+08:00</updated>
    <id>https://chenrenyi.github.io/15980638067464.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">String</h2>

<p>StringBuffer：线程安全<br/>
StringBuilder：线程不安全</p>

<h2 id="toc_1">集合</h2>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc?x-oss-process=image/format,png" alt=""/></p>

<h3 id="toc_2">List</h3>

<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>CopyOnWriteList</li>
<li>Collections.synchronizedList 内部包装类，用sync修饰方法</li>
</ul>

<h3 id="toc_3">Set</h3>

<ul>
<li>HashSet 基于HashMap</li>
<li>TreeSet 基于TreeMap</li>
</ul>

<h3 id="toc_4">Map</h3>

<p><img src="media/15980638067464/15980649696422.jpg" alt=""/></p>

<h4 id="toc_5">HashMap</h4>

<p><strong>特点</strong></p>

<ul>
<li>允许null值、null键</li>
<li>线程不安全</li>
</ul>

<p><strong>旧版底层实现</strong></p>

<ul>
<li>哈希表 + 链表</li>
</ul>

<p><strong>新版底层实现</strong></p>

<ul>
<li>哈希表 + 链表</li>
<li>链表长度大于8时，转化为红黑树（避免严重哈希冲突时，性能退化为单链表）</li>
</ul>

<p><strong>长度为啥是2的次方</strong></p>

<pre><code class="language-text">1、取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作
2、HashMap的key的hash采用上述方法，性能更高
3、所以分布在2的次方空间，长度取2的次方分布才均匀
</code></pre>

<h4 id="toc_6">ConcurrentHashMap</h4>

<p><strong>特点</strong><br/>
线程安全的HashMap</p>

<p><strong>版本1.7底层实现</strong><br/>
进一步采用分段的方式，每段配置一个锁。Segment继承自ReentranLock<br/>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ?x-oss-process=image/format,png" alt=""/></p>

<p><strong>版本1.8底层实现</strong><br/>
抛弃了分段方式，使用自旋锁 + Sychronized 方式来保证并发安全<br/>
put时，若key对应的value为null，通过cas保证写入成功，否则加Sychronized锁</p>

<p>对于读操作，由于数组被volatile关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个Node实例（Java 7中每个元素是一个HashEntry），它的Key值和hash值都由final修饰，不可变更，无须关心它们被修改后的可见性问题。而其Value及对下一个元素的引用由volatile修饰，可见性也有保障。</p>

<pre><code class="language-text">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
  final int hash;
  final K key;
  volatile V val;
  volatile Node&lt;K,V&gt; next;
}
</code></pre>

<p>对于Key对应的数组元素的可见性，由Unsafe的getObjectVolatile方法保证。</p>

<pre><code class="language-text">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {
  return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
}
</code></pre>

<h4 id="toc_7">TreeMap</h4>

<p>红黑树，Node.Key 即为 key，Node.value 即为 value</p>

<p>因此：</p>

<ul>
<li>不允许重复Key</li>
<li>可以排序，需要实验Compartable</li>
</ul>

<h3 id="toc_8">BlockingQueue</h3>

<p>阻塞队列，用于生产者消费者</p>

<ul>
<li>ArrayBlockingQueue (ReentrantLock.Condition来实现）</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue 优先级队列</li>
<li>DelayQueue 延时队列</li>
<li>SynchronousQueue （无缓存，生产者直接对接消费者）</li>
</ul>

<h2 id="toc_9">异常</h2>

<p><img src="https://img-blog.csdnimg.cn/20200314173417278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt=""/></p>

<h3 id="toc_10">try-with-resource</h3>

<p>自动关闭资源，需要实现AutoCloseAble接口</p>

<pre><code class="language-java">try (Scanner scanner = new Scanner(new FileInputStream(&quot;c:/abc&quot;),&quot;UTF-8&quot;)){
    // code
} catch (IOException e){
    // handle exception
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发]]></title>
    <link href="https://chenrenyi.github.io/15980740537693.html"/>
    <updated>2020-08-22T13:27:33+08:00</updated>
    <id>https://chenrenyi.github.io/15980740537693.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概念</h2>

<h3 id="toc_1">并发编程三要素：</h3>

<ul>
<li>原子性：要么成功要么失败</li>
<li>可见性：线程A修改完变量后，线程B能否感知</li>
<li>有序性：指令执行顺序</li>
</ul>

<h3 id="toc_2">Java内存模型</h3>

<p>即Java虚拟机的内存规范，用于屏蔽各操作系统和平台间的差异</p>

<p>具体内容：</p>

<ul>
<li>变量在主存中（内存）</li>
<li>线程有自己的工作内存（类似高速缓存）</li>
<li>线程对变量操作只能在自身工作内存中执行，不能直接操作主存</li>
</ul>

<p>内存模型关于三要素的保证：</p>

<ul>
<li>原子性
<ul>
<li>简单类型的赋值才是原子操作（x = 10 是，x = y 不是）</li>
</ul></li>
<li>可见性
<ul>
<li>不保证，需要使用volatile关键字</li>
</ul></li>
<li>有序性
<ul>
<li>允许使用指令重排序，对单线程无影响，对多线程会造成影响</li>
<li>能够保证的有：
<ul>
<li>保证单线程内指令重排序对最终结果无影响（也即实际执行顺序可能会变，但结果不变）</li>
<li>若 unlock 写在前面，lock写在后面，不会重排序造成lock在前</li>
<li>volatile变量，对它的先写后读操作，不会重排序成先读后写</li>
<li>线程4个顺序，不重要</li>
</ul></li>
</ul></li>
</ul>

<h3 id="toc_3">指令重排序</h3>

<p>操作系统为了性能优化，实际执行指令的顺序可能与书写顺序不一致</p>

<p>这种优化不会改变单线程的实际执行结果，但对多线程有影响</p>

<p>举例：</p>

<pre><code class="language-java">x = y;
z = 1;
z++;
x = x + z
</code></pre>

<pre><code class="language-text">对应cpu行为，x = y，去内存中取y的值，较慢
z = 1;z++;
可能对应设置寄存器为1，寄存器进行加1操作。
显然，等待 x = y的这段时间，先做后面两行代码操作是没问题的
</code></pre>

<h2 id="toc_4">Volatile</h2>

<p><strong>作用</strong></p>

<ul>
<li>禁止指令重排序
<ul>
<li>当程序执行到volatile变量的读或写时，保证前面的读写已发生且已可见，后面的读写未发生</li>
<li>书写顺序在volatile变量操作前面的指令不会排到后面，反之一样</li>
</ul></li>
<li>只保证可见性，不保证原子性</li>
</ul>

<p><strong>实现原理</strong><br/>
内存屏障，估计是cpu提供的功能：</p>

<ul>
<li>禁止指令重排序，同上</li>
<li>写操作立即刷新进主内存</li>
<li>线程的读volatile变量操作，不会使用高速缓存，而是会去主存再读一遍</li>
</ul>

<p><strong>场景举例</strong></p>

<pre><code class="language-java">//线程1
volatile boolean stop = false;
while(!stop){
    doSomething();
}
 
//线程2
stop = true;
</code></pre>

<h2 id="toc_5">锁</h2>

<h3 id="toc_6">概念</h3>

<ul>
<li>可重入锁
<ul>
<li>内部可以再次进入</li>
<li>假如用变量 x 来表示，进入锁即加1，超过1即不能再进入锁。那么已经获得锁的方法，递归调用自己，是不能获得锁的，即为不可重入锁。反之为可重入锁。</li>
</ul></li>
<li>公平锁：先等锁的先获得锁</li>
<li>非公平锁：等待队列上的线程，不分先后顺序，每次有机会时都随机指定一个</li>
<li>自旋锁：拿不到锁时不是线程阻塞，而是空白死循环去一直拿</li>
<li>乐观锁：默认无冲突，先操作再检测冲突</li>
<li>悲观锁：默认有冲突，先加锁再操作</li>
<li>独占锁：ReentrantLock/Synchronized</li>
<li>共享锁：ReentrantReadWriteLock，读锁为共享锁，写锁为独占锁</li>
</ul>

<h3 id="toc_7">Synchronized</h3>

<h4 id="toc_8">特性</h4>

<ul>
<li>可重入</li>
<li>抛出异常会自动释放锁</li>
</ul>

<h4 id="toc_9">版本差异</h4>

<p>版本1.6及之前</p>

<pre><code class="language-text">调用操作系统原生方法进行同步控制
</code></pre>

<p>版本1.6之后</p>

<ul>
<li>分为无状态锁、偏向锁、轻量级锁、重量级锁
<ul>
<li>默认用开销少的锁，竞争大的时候再升级，少的时候降级。因而可以优化性能</li>
</ul></li>
<li>锁粗化，即合并加锁</li>
<li>锁消除，判断代码有没有线程外的变量，来判断是否需要加锁</li>
<li>适应性自旋，即成功过一下一次循环就久一点，否则就短一点</li>
</ul>

<h4 id="toc_10">单例模式</h4>

<pre><code class="language-java">public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
</code></pre>

<pre><code class="language-text">volatile阻止的不是singleton = newSingleton()这句话内部[分配空间、初始化、赋值]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（if (instance == null)）
</code></pre>

<h3 id="toc_11">Lock</h3>

<h4 id="toc_12">ReadWriteLock</h4>

<p>读写锁</p>

<h4 id="toc_13">ReentrantLock - 排它锁</h4>

<p><strong>支持公平与非公平</strong></p>

<pre><code class="language-java">// 构造参数：isFair
Lock NonFairlock = new ReentrantLock(false);
Lock fairLock = new ReentrantLock(true);
</code></pre>
<br>
<p><strong>生产者消费者示例</strong></p>

<pre><code class="language-java">// 馒头生产消费示例
package cn.chenrenyi.start;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author chenrenyi
 **/
public class ProductAndConsumeQueue {

    public List&lt;Integer&gt; queue;

    private int maxQueueSize;

    private Lock lock;

    private Condition notFull;

    private Condition notEmpty;

    public ProductAndConsumeQueue(int maxQueueSize) {
        this.queue = new ArrayList&lt;&gt;();
        this.maxQueueSize = maxQueueSize;
        this.lock = new ReentrantLock(true);
        this.notFull = lock.newCondition();
        this.notEmpty = lock.newCondition();
    }

    public void push() {
        try {
            lock.lock();
            while (queue.size() == maxQueueSize) {
                try {
                    // wait until not full
                    System.out.println(&quot;队列已满，生产者休眠中，等待队列不满再生产&quot;);
                    notFull.await();
                    System.out.println(&quot;生产者被唤醒&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            // start to push because of not empty
            queue.add(new Random().nextInt());
            System.out.println(&quot;生产者生产了馒头&quot;);

            // signal to public that queue is not empty now.
            notEmpty.signal();

        } finally {
            lock.unlock();
        }
    }

    public void pop() {
        try {
            lock.lock();
            while (queue.size() == 0) {
                try {
                    // wait until not empty
                    System.out.println(&quot;队列已空，消费者进入休眠，等待队列不空时再消费&quot;);
                    notEmpty.await();
                    System.out.println(&quot;消费者被唤醒&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            // start to push because of not empty
            queue.remove(0);
            System.out.println(&quot;消费了馒头&quot;);

            // signal to public that queue is not full now.
            notFull.signal();

        } finally {
            lock.unlock();
        }
    }

    public static void test() {
        ProductAndConsumeQueue queue = new ProductAndConsumeQueue(4);

        Runnable productor = new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        TimeUnit.SECONDS.sleep(new Random().nextInt(5));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    queue.push();
                }
            }
        };

        Runnable consumer = new Runnable() {
            @Override
            public void run() {
                while(true) {
                    try {
                        TimeUnit.SECONDS.sleep(new Random().nextInt(5));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    queue.pop();
                }
            }
        };

        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(productor);
        executorService.execute(consumer);
        executorService.shutdown();
    }
}
</code></pre>

<h3 id="toc_14">相关类</h3>

<h4 id="toc_15">Atomic</h4>

<pre><code class="language-java">包：java.util.concurrent.atomic
示例：AtomicInteger.incrementAndGet()
</code></pre>
<br>
<p><strong>实现原理</strong><br/>
自旋加CAS+volatile：<code>while(cas(old, new)){}</code></p>

<p><strong>CAS</strong><br/>
compare and swap，cpu提供的指令，比较并替换。上述类的原理。</p>

<p><strong>ABA问题</strong><br/>
线程1将变量替换2，线程2又替换为1，线程3以为没变其实已经变过一轮了<br/>
解决方法：</p>

<ul>
<li>AtomicStampedReference：版本号解决，对原数加1时，对版本号也加1</li>
</ul>

<h4 id="toc_16">并发工具包</h4>

<ul>
<li>Semaphore（信号量）-允许多个线程同时访问</li>
<li>CountDownLatch（倒计时器）
<ul>
<li>一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行</li>
</ul></li>
<li>CyclicBarrier（循环栅栏）
<ul>
<li>一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行</li>
</ul></li>
</ul>

<h2 id="toc_17">线程</h2>

<h3 id="toc_18">线程池</h3>

<p>构造函数</p>

<pre><code class="language-java">/**
 * Creates a new {@code ThreadPoolExecutor} with the given initial
 * parameters.
 *
 * @param corePoolSize the number of threads to keep in the pool, even
 *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
 * @param maximumPoolSize the maximum number of threads to allow in the
 *        pool
 * @param keepAliveTime when the number of threads is greater than
 *        the core, this is the maximum time that excess idle threads
 *        will wait for new tasks before terminating.
 * @param unit the time unit for the {@code keepAliveTime} argument
 * @param workQueue the queue to use for holding tasks before they are
 *        executed.  This queue will hold only the {@code Runnable}
 *        tasks submitted by the {@code execute} method.
 * @param threadFactory the factory to use when the executor
 *        creates a new thread
 * @param handler the handler to use when execution is blocked
 *        because the thread bounds and queue capacities are reached
 * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;
 *         {@code corePoolSize &lt; 0}&lt;br&gt;
 *         {@code keepAliveTime &lt; 0}&lt;br&gt;
 *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;
 *         {@code maximumPoolSize &lt; corePoolSize}
 * @throws NullPointerException if {@code workQueue}
 *         or {@code threadFactory} or {@code handler} is null
 */
public ThreadPoolExecutor(int corePoolSize, 
                          int maximumPoolSize,
                          long keepAliveTime,
                          @NotNull TimeUnit unit,
                          @NotNull BlockingQueue&lt;Runnable&gt; workQueue,
                          @NotNull ThreadFactory threadFactory,
                          @NotNull RejectedExecutionHandler handler
</code></pre>

<h4 id="toc_19">失败处理策略</h4>

<pre><code class="language-text">AbortPolicy：A handler for rejected tasks that throws a RejectedExecutionException

DiscardPolicy：A handler for rejected tasks that silently discards the rejected task

DiscardOldestPolicy：A handler for rejected tasks that discards the oldest unhandled request and then retries execute, unless the executor is shut down, in which case the task is discarded.

CallerRunsPolicy：A handler for rejected tasks that runs the rejected task directly in the calling thread of the execute method, unless the executor has been shut down, in which case the task is discarded.
</code></pre>

<h4 id="toc_20">线程池种类</h4>

<p>newSingleThreadExecutor：单线程，无限队列，不回收</p>

<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
    }
</code></pre>

<p>newFixedThreadPool：固定线程数，无限队列，不回收</p>

<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
    }
</code></pre>

<p>newScheduledThreadPool：延迟或周期执行任务。</p>

<pre><code class="language-java">public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
</code></pre>

<p>newCachedThreadPool</p>

<pre><code class="language-java">// 无限队列，动态创建，60秒空闲即回收。使用同步队列 SynchronousQueue，提交任务操作会阻塞直到线程创建好并取出任务
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
    }
</code></pre>

<pre>
newWorkStealingPool：ForkJoinPool，1.7之后新增
</pre>

<h3 id="toc_21">ThreadLocal</h3>

<p>线程本地变量，线程内可见，线程外不可见</p>

<pre><code class="language-java">// 创建
ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();
ThreadLocal&lt;String&gt; mThreadLocal = new ThreadLocal&lt;String&gt;() {
    @Override
    protected String initialValue() {
      return Thread.currentThread().getName();
    }
};

// 使用
mStringThreadLocal.set(&quot;chenrenyi&quot;);
mStringThreadLocal.get();
</code></pre>

<p><strong>Set 创建过程</strong>：</p>

<ul>
<li>首先获取当前线程的成员变量：threadLocals，类型：ThreadLocalMap</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
<li>以当前 ThreadLocal 对象为 key，set 的参数值为值</li>
</ul>

<p>即创建一个 ThreadLocalMap ，再赋值给 Thread.threadLocals 属性上。map 的 key 为创建的 ThreadLocal 对象，值为值。其中 key 弱引用，避免内存泄漏</p>

<p><strong>为何只在线程内可见</strong>：</p>

<p>因为 threadLocalMap 是 thread 的一个成员变量，而每个 thread 的成员变量自然不一样，所以只在线程内可见</p>

<p><strong>对象存放在哪里</strong>：</p>

<p>堆上</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Jvm]]></title>
    <link href="https://chenrenyi.github.io/15980814209679.html"/>
    <updated>2020-08-22T15:30:20+08:00</updated>
    <id>https://chenrenyi.github.io/15980814209679.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">组成</h2>

<h3 id="toc_1">JVM组成</h3>

<p>两个子系统：</p>

<ul>
<li>类加载</li>
<li>执行引擎</li>
</ul>

<p>两个组件：</p>

<ul>
<li>运行时数据区 - JVM内存区域</li>
<li>本地方法接口</li>
</ul>

<p><img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt=""/></p>

<h3 id="toc_2">JVM内存结构 - 运行时数据区 组成</h3>

<h4 id="toc_3">概述</h4>

<ul>
<li>堆内存
<ul>
<li>年轻代
<ul>
<li>edenSpace</li>
<li>FromSpace</li>
<li>ToSpace</li>
</ul></li>
<li>老年代</li>
</ul></li>
<li>方法区
<ul>
<li>线程共享，保存类、常量、静态变量等数据</li>
</ul></li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
</ul>

<p><img src="media/15980814209679/15980817654033.jpg" alt=""/></p>

<p><img src="media/15980814209679/15980819260266.jpg" alt=""/></p>

<p>大小参数控制：</p>

<ul>
<li>-Xms设置堆的最小空间大小。</li>
<li>-Xmx设置堆的最大空间大小。</li>
<li>-XX:NewSize设置新生代最小空间大小。</li>
<li>-XX:MaxNewSize设置新生代最大空间大小。</li>
<li>-XX:PermSize设置永久代最小空间大小。</li>
<li>-XX:MaxPermSize设置永久代最大空间大小。</li>
<li>-Xss设置每个线程的堆栈大小。</li>
</ul>

<h4 id="toc_4">堆</h4>

<p>几乎所有的对象实例都在这里分配内存</p>

<h4 id="toc_5">方法区</h4>

<p>各线程共享</p>

<p><strong>1.6及之前版本</strong></p>

<ul>
<li>类信息、类方法等</li>
<li>运行时常量池（包含字符串常量池）</li>
<li>静态变量和全局变量等</li>
<li>符号引用</li>
</ul>

<p><strong>1.7版本</strong></p>

<ul>
<li>静态变量和字符串常量池被移到堆中</li>
<li>符号引用被移到本地堆中</li>
</ul>

<p><strong>1.8版本</strong></p>

<ul>
<li>基本上只包含类信息</li>
</ul>

<p><img src="media/15980814209679/15980825256187.jpg" alt=""/></p>

<h4 id="toc_6">程序计数器</h4>

<p>同汇编中的 PC 寄存器，存储下一条要执行的指令位置，理论上每个线程需要有一个</p>

<h4 id="toc_7">JVM栈</h4>

<p>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p>

<p>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>

<p><strong>局部变量表</strong></p>

<ul>
<li>基本类型的局部变量</li>
<li>非基本类型对象的引用指针</li>
</ul>

<h4 id="toc_8">关于永久代、方法区、元空间</h4>

<p><strong>1.7 版本前：</strong></p>

<p>从HotSpot虚拟机实现上来说，方法区存在于永久代中。从规范上来讲没有永久代这一概念。</p>

<p>永久代的历史原因是：HotSpot虚拟机的实现上，无论老年代、还是方法区内存满了，都会触发方法区和老年代的GC，因此称之为永久代</p>

<p>永久代与堆隔离，但物理内存上连续</p>

<p><strong>1.8 版本：</strong></p>

<p>方法区存在于元空间中，元空间存在于本地内存中</p>

<ul>
<li><p>-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。</p></li>
<li><p>-XX：MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。</p></li>
<li><p>-XX：MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。</p></li>
<li><p>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集。</p></li>
</ul>

<p><strong>为什么替代</strong></p>

<p>旧方法中，永久代大小由 -XX:PermSize，-XX:MaxPermSize指定，无法准确知道该设置的合适值。</p>

<p>新方法中，元空间移到了本地内存，可以由系统实际剩余内存控制</p>

<h2 id="toc_9">类加载机制</h2>

<p><img src="https://img-blog.csdnimg.cn/2020031416414486.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt=""/></p>

<h4 id="toc_10">加载过程</h4>

<p><img src="media/15980814209679/15980830126011.jpg" alt=""/></p>

<p><strong>加载：加载对应的.class文件，并分配内存和对象</strong></p>

<ul>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p></li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li>
<li><p>在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。</p></li>
</ul>

<p><strong>验证：验证类格式是否合法</strong></p>

<ul>
<li><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></li>
<li><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</p></li>
<li><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></li>
<li><p>符号引用验证：确保解析动作能正确执行。</p></li>
</ul>

<p><strong>准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p>

<ul>
<li><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p></li>
<li><p>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p></li>
<li><p>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值</p></li>
<li><p>public static int value = 3，准备后其值为 0</p></li>
<li><p>public final static int value = 3，准备后其值为 3</p></li>
</ul>

<p><strong>解析：把类中的符号引用转换为直接引用</strong></p>

<ul>
<li><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p></li>
<li><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li>
</ul>

<p><strong>初始化：为静态成员变量赋予初始值</strong></p>

<p>初始化，为类的<strong>静态变量</strong>赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>

<ol>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ol>

<p>JVM初始化步骤</p>

<ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>

<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>

<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li>
</ul>

<p><strong>注意</strong><br/>
类的非静态成员变量，只有在创建实例时，才会被初始化到堆中</p>

<h4 id="toc_11">加载器</h4>

<p><img src="media/15980814209679/15980841148150.jpg" alt=""/></p>

<p><strong>启动类加载器</strong>： BootstrapClassLoader，加载虚拟机类库，本地方法<br/>
<strong>扩展类加载器</strong>： ExtensionClassLoader，加载系统类库<br/>
<strong>应用程序类加载器</strong>：ApplicationClassLoader，加载用户类的路径</p>

<h4 id="toc_12">加载机制</h4>

<p><strong>全盘负责</strong><br/>
当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>

<p><strong>双亲委派</strong><br/>
先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>

<p><strong>缓存机制</strong><br/>
缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>

<h2 id="toc_13">垃圾回收算法</h2>

<h3 id="toc_14">对象存活判断</h3>

<p><strong>引用计数</strong>：<br/>
有循环引用问题</p>

<p><strong>可达性分析</strong><br/>
GC Roots：</p>

<ul>
<li>虚拟机栈中引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
<li>方法区中类静态属性实体引用的对象。</li>
<li>方法区中常量引用的对象。</li>
</ul>

<h3 id="toc_15">垃圾收集算法</h3>

<h4 id="toc_16">标记 - 清除算法</h4>

<p>过程：</p>

<ul>
<li>标记不需要的对象</li>
<li>清除</li>
</ul>

<p>特点：</p>

<ul>
<li>标记效率不高</li>
<li>清除后产生大量内存碎片</li>
</ul>

<h4 id="toc_17">复制算法</h4>

<p>过程：</p>

<ul>
<li>内存分为两块</li>
<li>将一块中的存活对象，复制到另一半</li>
</ul>

<p>特点：</p>

<ul>
<li>没有内存碎片</li>
<li>内存利用率不高</li>
<li>存活对象多时要复制大量数据，性能慢。适合于新生代，存活对象很少的情况</li>
</ul>

<h4 id="toc_18">标记 - 压缩/整理算法</h4>

<p>过程：</p>

<ul>
<li>标记</li>
<li>向一端移动</li>
</ul>

<h4 id="toc_19">分代收集算法</h4>

<p>即根据新生代、老年代特性，采用不同的收集算法</p>

<h3 id="toc_20">垃圾收集器</h3>

<h4 id="toc_21">Serial收集器</h4>

<p>最古老版本</p>

<p>特点：</p>

<ul>
<li>单线程回收</li>
<li>新生代复制，老年代标记-压缩</li>
<li>过程中 STW</li>
</ul>

<p>使用：-XX:+UseSerialGC</p>

<h4 id="toc_22">ParNew收集器</h4>

<p>Serial收集器并行版本</p>

<p>特点：</p>

<ul>
<li>新生代多线程复制</li>
<li>老年代串行标记-压缩</li>
</ul>

<p>使用：-XX:+UseParNewGC</p>

<h4 id="toc_23">Parallel</h4>

<p>类似于ParNew，更关注系统吞吐量</p>

<p>可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>

<p>使用：-XX:+UseParallelGC 老年代串行</p>

<h4 id="toc_24">Parallel Old 收集器</h4>

<p>Parallel的老年代版本，老年代并行标记 - 压缩</p>

<p>使用：-XX:+UseParallelOldGC 使用Parallel收集器 + 老年代并行</p>

<h4 id="toc_25">CMS收集器</h4>

<p>Concurrent Mark Sweep：并行标记清除</p>

<p>目标：追求最短停顿时间</p>

<p>过程：</p>

<ul>
<li>触发条件
<ul>
<li>老年代、永久代使用率达到92%</li>
<li>新生代没有足够的空间晋升为老年代</li>
</ul></li>
<li>初始标记
<ul>
<li>STW</li>
<li>标记GC roots直接关联的老年代对象、标记新生代可达的老年代对象</li>
<li>速度快</li>
</ul></li>
<li>并发标记
<ul>
<li>递归标记上一步骤中，已标记对象的内部可引用对象</li>
<li>并发标记过程中发生变化的，记号为dirty</li>
<li>时间长，但并发执行</li>
</ul></li>
<li>并发预清理
<ul>
<li>标记新生代中的新出现对象引用的老年代对象，新晋升的老年代对象</li>
<li>扫描上一阶段中的dirty对象，重新处理</li>
<li>循环直至达到最大循环次数（默认无），最长时间（默认5秒）</li>
<li>目的是尽量减少下一阶段的暂停时间</li>
</ul></li>
<li>重新标记
<ul>
<li>STW</li>
<li>修正并发标记期间，因程序运作导致的误差
<ul>
<li>重新扫描新生代</li>
<li>重新扫码GC roots可达对象</li>
<li>处理标记为dirty的对象</li>
</ul></li>
<li>时间中等</li>
</ul></li>
<li>并发清除
<ul>
<li>不会STW</li>
</ul></li>
</ul>

<p>优点：</p>

<ul>
<li>并发收集，低停顿</li>
</ul>

<p>缺点：</p>

<ul>
<li>标记 - 清除算法会产生大量碎片、并发阶段会降低吞吐量</li>
</ul>

<p>参数使用：</p>

<ul>
<li>-XX:+UseConcMarkSweepGC 使用CMS收集器</li>
<li>-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长</li>
<li>-XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理</li>
<li>-XX:ParallelCMSThreads 设定CMS的线程数量（一般情况约等于可用CPU数量）</li>
</ul>

<h4 id="toc_26">G1收集器</h4>

<p>特点：</p>

<ul>
<li>标记 - 压缩，不会产生碎片</li>
<li>将内存划分为若干区域，新生代、老年代等是各个区域的组合</li>
<li>每个区块一个rememberd set，记录进入的指针</li>
<li>预测各区块的回收时间，回收部分区块，从而达到可预测时间的目的</li>
</ul>

<p><img src="media/15980814209679/15980908684125.jpg" alt=""/></p>

<p><img src="media/15980814209679/15981482084026.jpg" alt=""/></p>

<h3 id="toc_27">GC调优工具</h3>

<h4 id="toc_28">自带图形工具</h4>

<ul>
<li>jconsole</li>
<li>jvisualvm</li>
</ul>

<h4 id="toc_29">命令行工具</h4>

<ul>
<li><p>jps：打印java process status</p>
<p><img src="media/15980814209679/15980939009037.jpg" alt="" style="width:303px;"/></p></li>
<li><p>jstat：</p>
<ul>
<li>JVM statistics Monitoring</li>
<li>用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li>
</ul></li>
</ul>

<p><img src="media/15980814209679/15980939723822.jpg" alt="" style="width:411px;"/></p>

<ul>
<li>jmap：生成堆快照</li>
<li>jhat：分析堆快照</li>
<li>jstack：生成线程快照</li>
<li>jinfo：查看虚拟机参数</li>
</ul>

<h4 id="toc_30">GC优化</h4>

<ul>
<li>-Xms -Xmx调整初始堆大小和最大堆大小适配机器内存大小</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ForkJoinPool 相关]]></title>
    <link href="https://chenrenyi.github.io/15922331141719.html"/>
    <updated>2020-06-15T22:58:34+08:00</updated>
    <id>https://chenrenyi.github.io/15922331141719.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-java">package fighting.threads;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;

/**
 * ForkJoinPool学习
 * 不同之处：
 * 1、没有一个公共的任务队列，而是每个工作线程都有自己两个任务队列（外部和内部产生的子任务）
 * 2、目的是避免处理大量短平快任务时，对公共队列任务的争抢引发性能问题。即每个任务执行都很快，但多并发情况下公共任务队列push和pop的加锁成为了瓶颈
 *
 * 两个作用：
 * 1、分而治之，允许任务执行过程中，再次提交子任务，从而缩短时间
 * 2、工作窃取，线程池中已完成的工作线程，将主动获取所有线程队列中已提交未完成的任务或子任务
 *
 * 对应的类：
 * ForkJoinPool：线程池
 * ForkJoinPool.common：全局公用的线程池
 * ForkJoinTask：有返回值的任务
 * ForkJoinAction：没有返回值任务
 *
 * 相关类：
 * Executors.newWorkStealingPool()
 * stream.parallelStream()
 */
public class ForkJoinPoolTest {

    /**
     * 测试入口
     */
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ForkJoinPool pool = new ForkJoinPool(10);
        ForkJoinTask&lt;Integer&gt; result = pool.submit(new CalcIntegerTask(0, 100000));
        System.out.println(result.get());
        pool.shutdown();

        // 通过executors创建线程池
        Executors.newWorkStealingPool().submit(() -&gt; System.out.println(&quot;a runnable task&quot;));

        // parallelStream（pærəlel），默认使用 ForkJoinPool.common
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
        numbers.parallelStream().forEach(System.out::println);
    }

}

/**
 * 数字计算任务
 */
class CalcIntegerTask extends RecursiveTask&lt;Integer&gt; {

    private Integer start;

    private Integer end;

    public CalcIntegerTask(Integer start, Integer end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        int sum = 0;
        if (end - start &lt;= 100) {
            // 数据量少时直接计算
            for (int i = start; i &lt;= end; i++) {
                sum += i;
            }
        } else {
            // 数据量大时，分而治之。拆分子任务提交
            int middle = (end - start) / 2 + start;
            CalcIntegerTask leftTask = new CalcIntegerTask(start, middle);
            CalcIntegerTask rightTask = new CalcIntegerTask(middle + 1, end);

            // 子任务需要调用 fork 方法
            leftTask.fork();
            rightTask.fork();

            // 使用 join 方法等待并获取值
            sum = leftTask.join() + rightTask.join();
        }

        return sum;
    }
}

</code></pre>

]]></content>
  </entry>
  
</feed>
